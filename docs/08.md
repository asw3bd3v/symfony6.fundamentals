# debug:container & How Autowiring Works

Ладно, я соврал. Прежде чем мы поговорим об окружениях, мне нужно кое в чем признаться: я не показывал вам все сервисы в Symfony. Даже близко нет.

Откройте свой терминал и выполните нашу любимую команду:

```
php bin/console debug:autowiring
```

Мы знаем, что все эти сервисы плавают в Symfony, ожидая, когда мы их попросим. И мы знаем, что пакеты предоставляют нам сервисы. Сервис Twig здесь взят из TwigBundle.

И поскольку каждая служба является объектом, что-то где-то должно отвечать за создание экземпляров этих объектов. Вопрос: «Кто?» И ответ... контейнер служб (service container)!

## Hello Service Container

Оказывается, все службы на самом деле не... "плавают вокруг": все они находятся внутри чего-то, что называется "контейнер". И в контейнере гораздо больше служб, чем нам рассказал debug:autowiring. Ох... секреты! На этот раз запустите:

```
php bin/console debug:container
```

И... ух ты! Это распечатывает огромный список. Он такой большой, что трудно все увидеть. Давайте я сделаю шрифт поменьше. Намного лучше!

Это полный список всех служб в нашем приложении... или в "контейнере". Контейнер по сути является гигантским "массивом", где каждая служба имеет уникальное имя, указывающее на ее объект службы. Например, здесь внизу... вот мы идем... мы видим, что есть служба, чье уникальное имя - или "id" - twig.

Знание того, что идентификатором службы Twig является twig, обычно не так уж и важно, но полезно понимать, что у каждой службы есть уникальный идентификатор... и что вы можете увидеть их все внутри команды debug:container.

## Контейнер создает объекты

И действительно, контейнер можно было бы лучше описать как большой массив инструкций о том, как инстанцировать службы, если и когда что-то их запрашивает. Например, контейнер точно знает, как инстанцировать эту службу Twig. Он знает, что ее класс — Twig\Environment. И хотя вы не видите его в этом списке, он знает точные аргументы для передачи его конструктору. В тот момент, когда кому-то нужна служба Twig, контейнер инстанцирует ее и возвращает.

Да, когда мы автоматически подключаем службу, мы по сути говорим:

> Привет, контейнер, можешь ли ты предоставить мне службу HTTP-клиента?

Если в нашем коде еще ничего не запрашивало эту службу во время этого запроса, контейнер создаст ее. Но если что-то уже запросило ее, то контейнер просто вернет ту, которую он уже создал. Это означает, что если мы запросим службу HTTP Client в десяти разных местах, контейнер создаст и вернет только один экземпляр. Довольно круто!

## How Autowiring Works

В любом случае, debug:container показывает нам все сервисы, которые контейнер знает, как инстанцировать. Но debug:autowiring показывает нам только часть этих сервисов. Почему?

Ну, оказывается, не все службы поддерживают автоподключение. Многие из пунктов в этом списке — это низкоуровневые службы, которые существуют только для того, чтобы помогать другим службам выполнять свою работу. Вам, вероятно, никогда не понадобится использовать эти низкоуровневые службы напрямую... и вы на самом деле не можете получить их через автоподключение.

Но давайте вернемся на минуту назад. Теперь, когда мы знаем немного больше, мы можем узнать, как именно работает система автосвязывания Symfony. Она прекрасно проста.

Как мы уже видели, контейнер на самом деле является массивом, где каждая служба имеет идентификатор, указывающий на этот объект службы. Когда Symfony видит этот тип HttpClientInterface — это полный тип, который он видит благодаря нашему оператору use — чтобы выяснить, какую службу в контейнере ему нужно нам передать, он просто ищет службу, идентификатор которой точно соответствует этой строке. Позвольте мне показать вам!

Прокрутите список вверх, чтобы найти... службу с идентификатором Symfony\Contracts\HttpClient\HttpClientInterface! Подавляющее большинство служб в контейнере используют стратегию именования "snake case". Но если служба предназначена для использования в нашем коде, Symfony добавит дополнительную службу внутри, которая соответствует имени ее класса или интерфейса.

Благодаря этому, когда мы указываем тип HttpClientInterface, Symfony ищет в контейнере службу с идентификатором Symfony\Contracts\HttpClient\HttpClientInterface, находит ее и передает нам.

## Service Aliases

Но посмотрите на правую сторону: там написано, что это псевдоним для другого идентификатора сервиса. «Псевдоним» — это как символическая ссылка. Это означает, что когда кто-то запрашивает сервис HttpClientInterface, Symfony фактически передаст нам этот другой сервис.

Мы можем использовать ту же логику здесь для типа CacheInterface. Если мы проверим список, вот служба, чей идентификатор соответствует этому типу. Но на самом деле это просто псевдоним для службы под названием cache.app. Поэтому, когда мы автоматически подключаем CacheInterface, служба cache.app — это то, что на самом деле передается нам.

Если вы не уверены, вот три важных вывода. Первый: вокруг плавает множество объектов служб, и все они находятся внутри чего-то, что называется «контейнером». У каждой службы есть уникальный идентификатор.

Во-вторых, только небольшой процент из них полезен для нас... и они настроены так, чтобы мы могли их автоматически связать. Автоматическая связь работает, просматривая контейнер на предмет службы, чей идентификатор точно соответствует типу. Когда мы запускаем debug:autowiring, она в основном просто показывает нам службы из этого списка, чей идентификатор является именем класса или интерфейса. Это «автоматически связываемые службы».

Третий и последний вывод заключается в том, что у служб также есть система псевдонимов... что просто означает, что когда мы запрашиваем службу CacheInterface, на самом деле она нам вернет службу с идентификатором cache.app.

Если вам интересно, как мы могли бы использовать неавтоподключаемую службу в нашем коде, это отличный вопрос! Это довольно редкое явление, но мы узнаем, как это сделать позже.

Далее поговорим об использовании различных конфигураций локально и в производстве. Давайте поговорим о средах.
