# Bundle Config (to Control Bundle Services)

Теперь мы используем службы HttpClientInterface и CacheInterface. Ура! Но на самом деле мы не отвечаем за создание экземпляров этих объектов служб. Нет, они создаются чем-то другим (мы поговорим об этом через несколько минут), а затем просто передаются нам.

Это здорово, потому что все эти сервисы — «инструменты» нашего приложения — готовы к использованию, из коробки. Но... если что-то еще отвечает за создание экземпляров этих сервисных объектов, как мы можем ими управлять?

Представляем: конфигурацию пакета!

## Bundle Configuration

Проверьте каталог config/packages/. В нем есть несколько различных файлов YAML, все из которых автоматически загружаются Symfony при первой загрузке. Все эти файлы имеют ровно одну цель: настроить сервисы, которые предоставляет нам каждый пакет.

Откройте twig.yaml:

```twig
twig:
    default_path: '%kernel.project_dir%/templates'
when@test:
    twig:
        strict_variables: true
```

Пока что проигнорируйте это when@test: мы поговорим об этом через несколько минут. У этого файла есть корневой ключ, называемый twig. Итак, вся цель этого файла — контролировать службы, предоставляемые пакетом «Twig». И важно не имя файла — twig.yaml. Я мог бы переименовать его в pineapple_pizza.yaml, и он бы работал точно так же и был бы вкусным. Мне все равно, что вы думаете.

Когда Symfony загружает этот файл, он видит этот корневой ключ — twig — и говорит:

> О, ладно. Я собираюсь передать любую конфигурацию ниже в TwigBundle.

И помните! Пакеты предоставляют нам сервисы. Благодаря этой конфигурации, когда TwigBundle готовит свои сервисы, Symfony передает ему эту конфигурацию, и TwigBundle использует ее, чтобы решить, как должны быть созданы его сервисы... например, какие имена классов использовать для каждого сервиса... или какие первые, вторые или третьи аргументы конструктора передавать.

Например, если мы изменим default_path на что-то вроде %kernel.project_dir%/views, то служба Twig, которая отображает шаблоны, теперь будет предварительно настроена для поиска в этом каталоге.

Суть в том, что конфигурация в этих файлах дает нам возможность контролировать услуги, предоставляемые каждым пакетом.

Давайте рассмотрим еще один: framework.yaml:

```yaml
framework:
    secret: "%env(APP_SECRET)%"
    #csrf_protection: true
    http_method_override: false
    # Enables session support. Note that the session will ONLY be started if you read or write from it.
    # Remove or comment this section to explicitly disable session support.
    session:
        handler_id: null
        cookie_secure: auto
        cookie_samesite: lax
        storage_factory_id: session.storage.factory.native
    #esi: true
    #fragments: true
    php_errors:
        log: true
when@test:
    framework:
        test: true
        session:
            storage_factory_id: session.storage.factory.mock_file
```

Поскольку корневым ключом является framework, вся эта конфигурация передается в FrameworkBundle, который использует ее для настройки предоставляемых им служб.

И, как я уже говорил, имя файла не имеет значения... хотя имя часто совпадает с корневым ключом... просто из соображений здравого смысла: как framework и framework.yaml. Но это не всегда так. Откройте cache.yaml:

config/packages/cache.yaml

```yaml
framework:
    cache:
        # Unique name of your app: used to compute stable namespaces for cache keys.
        #prefix_seed: your_vendor_name/app_name
        # The "app" cache stores to the filesystem by default.
        # The data in this cache should persist between deploys.
        # Other options include:
        # Redis
        #app: cache.adapter.redis
        #default_redis_provider: redis://localhost
        # APCu (not recommended with heavy random-write workloads as memory fragmentation can cause perf issues)
        #app: cache.adapter.apcu
        # Namespaced pools use the above "app" backend by default
        #pools:
            #my.dedicated.cache: null
```

Ого! Это... просто еще одна конфигурация для FrameworkBundle! Он находится в своем собственном файле... просто потому, что приятно иметь отдельный файл для управления кэшем.

## Отладка доступной конфигурации пакета

В этот момент вы, возможно, задаетесь вопросом:

> Хорошо, круто... но какие ключи конфигурации нам разрешено здесь размещать? Где я могу узнать, какие опции доступны?

Отличный вопрос! Потому что... вы не можете просто "изобрести" любые ключи, которые захотите: это приведет к ошибке. Во-первых, да, вы можете, конечно, прочитать документацию. Но есть и другой способ: и это одна из моих любимых вещей в системе конфигурации Symfony.

Если вы хотите узнать, какую конфигурацию вы можете передать в пакет "Twig", есть две команды bin/console, которые вам помогут. Первая:

```
php bin/console debug:config twig
```

Это выведет всю текущую конфигурацию под ключом twig, включая любые значения по умолчанию, которые добавляет пакет. Вы можете увидеть, что наш default_path установлен в каталог templates/, который берется из нашего файла конфигурации. Этот %kernel.project_dir% — просто причудливый способ указать на корень нашего проекта. Подробнее об этом позже.

Попробуйте это: измените значение на views, повторно запустите эту команду и... да! Мы видим "views" в выводе. Позвольте мне продолжить и изменить это обратно.

Итак, debug:config показывает нам всю фактическую, текущую конфигурацию для определенного пакета, например twig... что особенно удобно, поскольку оно также показывает вам значения по умолчанию, добавленные пакетом. Это отличный способ увидеть, что вы можете настроить. Например, очевидно, мы можем добавить глобальную переменную в Twig через этот ключ globals!

Вторая команда похожа: вместо debug:config используется config:dump:

```
php bin/console config:dump twig
```

debug:config показывает текущую конфигурацию... но config:dump показывает гигантское дерево примеров конфигурации, которое включает все, что возможно. Здесь вы можете увидеть глобалы с некоторыми примерами того, как вы можете использовать этот ключ. Это отличный способ увидеть все потенциальные опции, которые вы можете передать пакету... чтобы помочь ему настроить свои службы.

Давайте используем эти новые знания, чтобы посмотреть, сможем ли мы «научить» службу кэширования хранить свои файлы в другом месте. Это следующее.