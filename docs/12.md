# Dependency Injection / Внедрение зависимостей

Наш сервис MixRepository работает. Мы можем автоматически подключить его к нашему контроллеру, и контейнер создаст экземпляр объекта и передаст его нам. Мы докажем это здесь, потому что при запуске кода он успешно вызывает метод findAll().

Но... затем он взрывается. Это потому, что внутри MixRepository у нас есть две неопределенные переменные. Для того, чтобы наш класс мог выполнять свою работу, ему нужны две службы: служба $cache и служба $httpClient.

## Автоматическое присоединение (Autowiring) к методам — это суперспособность, доступная только контроллеру

Я продолжаю говорить, что внутри Symfony плавает множество сервисов, ожидающих, когда мы их используем. Это правда. Но вы не можете просто так взять их из воздуха из любого места вашего кода. Например, нет статического метода Cache::get(), который вы можете вызвать, когда захотите, и который вернет объект сервиса $cache. Ничего подобного в Symfony нет. И это хорошо! Позволить нам брать объекты из воздуха — это рецепт написания плохого кода.

Так как же нам получить доступ к этим сервисам? В настоящее время мы знаем только один способ: автоматическое подключение их к нашему контроллеру. Но здесь это не сработает. Автоматическое подключение сервисов к методу — это суперспособность, которая работает только для контроллеров.

Смотрите: если бы мы добавили аргумент CacheInterface... а затем перешли бы и обновили, то увидели бы:

> Слишком мало аргументов для функции [...]findAll(), передано 0 [...], ожидалось ровно 1.

Это потому, что мы вызываем findAll(). Так что если findAll() нужен аргумент, то мы обязаны его передать: никакой магии Symfony нет. Я хочу сказать: автосвязывание работает в методах контроллера, но не ждите, что оно будет работать для любых других методов.

## Передача служб методу вручную?

Но один из способов заставить это работать — добавить обе службы в метод findAll(), а затем вручную передать их из контроллера. Это не будет окончательным решением, но давайте попробуем.

У меня уже есть аргумент CacheInterface... так что теперь добавьте аргумент HttpClientInterface и назовите его $httpClient:

src/Service/MixRepository.php

```php
use Symfony\Contracts\Cache\CacheInterface;
use Symfony\Contracts\HttpClient\HttpClientInterface;
class MixRepository
{
    public function findAll(HttpClientInterface $httpClient, CacheInterface $cache): array
    {
// ... lines 13 - 18
    }
}
```

Отлично! Код в этом методе теперь работает.

Вернемся к нашему контроллеру, для findAll() передадим $httpClient и $cache:

src/Controller/VinylController.php

```php
class VinylController extends AbstractController
{
// ... lines 15 - 33
    public function browse(HttpClientInterface $httpClient, CacheInterface $cache, MixRepository $mixRepository, string $slug = null): Response
    {
// ... lines 36 - 37
        $mixes = $mixRepository->findAll($httpClient, $cache);
// ... lines 39 - 43
    }
}
```

И вот... это работает!

## «Зависимости» против «Аргументов» / "Dependencies" Versus "Arguments"

Итак, на высоком уровне это решение имеет смысл. Мы знаем, что можем автоматически подключать службы к нашему контроллеру... а затем просто передавать их в MixRepository. Но если вы подумаете немного глубже, службы $httpClient и $cache на самом деле не являются входными данными для функции findAll(). Они не имеют смысла как аргументы.

Давайте рассмотрим пример. Представьте, что мы решили изменить метод findAll(), чтобы он принимал аргумент строки $genre, так что метод будет возвращать только миксы для этого жанра. Этот аргумент имеет смысл: передача разных жанров изменяет то, что он возвращает. Аргумент управляет поведением метода.

Но аргументы $httpClient и $cache не контролируют поведение функции. На самом деле, мы бы передали эти два значения каждый раз, когда вызываем метод... просто чтобы все работало.

Вместо аргументов, это на самом деле зависимости, которые нужны сервису. Это просто вещи, которые должны быть доступны, чтобы findAll() мог выполнять свою работу!

## Внедрение зависимостей и конструктор

Для таких "зависимостей", будь то объекты служб или статическая конфигурация, которая нужна вашей службе, вместо передачи их методам мы передаем их в конструктор. Удалите этот фиктивный аргумент $genre... затем добавьте публичную функцию \_\_construct(). Скопируйте два аргумента, удалите их и переместите сюда:

src/Service/MixRepository.php

```php
class MixRepository
{
// ... lines 11 - 13
    public function __construct(HttpClientInterface $httpClient, CacheInterface $cache)
    {
// ... lines 16 - 17
    }
// ... lines 19 - 28
}
```

Прежде чем мы закончим, мне нужно сказать вам, что автосвязывание работает в двух местах. Мы уже знаем, что можем автосвязывать аргументы в наши методы контроллера. Но мы также можем автосвязывать аргументы в метод \_\_construct() любой службы. Фактически, это основное место, где автосвязывание должно работать! Тот факт, что автосвязывание также работает для методов контроллера, это... своего рода «дополнение», просто чтобы сделать жизнь приятнее.

В любом случае, автосвязывание работает в методе \_\_construct() наших сервисов. Так что пока мы указываем подсказки по типу аргументов (а мы это делаем), когда Symfony инстанцирует наш сервис, он передаст нам эти два сервиса. Ура!

И что мы делаем с этими двумя аргументами? Мы устанавливаем их на свойства.

Создайте частное свойство $httpClient и частное свойство $cache. Затем, в конструкторе, назначьте им: $this->httpClient = $httpClient и $this->cache = $cache:

```php
class MixRepository
{
    private $httpClient;
    private $cache;
    public function __construct(HttpClientInterface $httpClient, CacheInterface $cache)
    {
        $this->httpClient = $httpClient;
        $this->cache = $cache;
    }
// ... lines 19 - 28
}
```

Поэтому, когда Symfony создает экземпляр нашего MixRepository, он передает нам эти два аргумента, и мы сохраняем их в свойствах, чтобы иметь возможность использовать их позже.

Смотрите! Здесь внизу вместо $cache используйте $this->cache. И тогда нам не нужно использовать ($httpClient) здесь... потому что мы можем сказать $this->httpClient:

```php
class MixRepository
{
// ... lines 11 - 19
    public function findAll(): array
    {
        return $this->cache->get('mixes_data', function(CacheItemInterface $cacheItem) {
// ... line 23
            $response = $this->httpClient->request('GET', 'https://raw.githubusercontent.com/SymfonyCasts/vinyl-mixes/main/mixes.json');
// ... lines 25 - 26
        });
    }
}
```

Теперь эта услуга в идеальном состоянии.

Вернемся в VinylController, теперь мы можем упростить! Методу findAll() не нужны никакие аргументы... и поэтому нам вообще не нужно автопривязывать $httpClient или $cache. Я собираюсь отпраздновать это, удалив эти операторы use сверху:

```php
class VinylController extends AbstractController
{
// ... lines 13 - 31
    public function browse(MixRepository $mixRepository, string $slug = null): Response
    {
// ... lines 34 - 35
        $mixes = $mixRepository->findAll();
// ... lines 37 - 41
    }
}
```

Посмотрите, насколько это проще! Мы автоматически подключаем одну нужную нам службу, вызываем метод на ней, и... она даже работает! Вот как мы пишем службы. Мы добавляем любые зависимости в конструктор, устанавливаем их на свойства, а затем используем их.

## Hello Dependency Injection!

Кстати, то, что мы только что сделали, имеет модное шманское название: "Внедрение зависимости" (Dependency Injection). Но не убегайте! Это может быть пугающим... или, по крайней мере, "скучно звучащим" термином, но это очень простая концепция.

Когда вы находитесь внутри сервиса вроде MixRepository и понимаете, что вам нужна другая служба (или, может быть, какая-то конфигурация вроде ключа API), чтобы получить ее, создайте конструктор, добавьте аргумент для нужной вам вещи, установите его в свойстве, а затем используйте его в своем коде. Да! Это внедрение зависимостей.

Проще говоря, внедрение зависимости означает:

> Если вам что-то нужно, вместо того, чтобы брать это из воздуха, заставьте Symfony передать это вам через конструктор.

Это одна из важнейших концепций в Symfony... и мы будем делать это снова и снова.

## PHP 8 Property Promotion

Хорошо, не связанные с внедрением зависимостей и автосвязыванием, есть два небольших улучшения, которые мы можем сделать для нашего сервиса. Первое — мы можем добавлять типы к нашим свойствам: HttpClientInterface и CacheInterface:

```php
class MixRepository
{
// ... lines 11 - 13
    public function __construct(HttpClientInterface $httpClient, CacheInterface $cache)
    {
        $this->httpClient = $httpClient;
        $this->cache = $cache;
    }
// ... lines 19 - 28
}
```

Это не меняет принципа работы нашего кода... это просто хороший и ответственный способ что-то делать.

Но мы можем пойти дальше! В PHP 8 появился новый, более короткий синтаксис для создания свойства и установки его в конструкторе, как мы это делаем. Выглядит это так. Сначала я перенесу свои аргументы на несколько строк... просто чтобы все было организовано. Теперь добавлю слово private перед каждым аргументом. Закончим, удалив свойства... а также внутреннюю часть метода.

На первый взгляд это может показаться странным, но как только вы добавляете private, protected или public перед аргументом __construct(), создается свойство с этим именем и аргумент устанавливается для этого свойства:

```php
class MixRepository
{
    public function __construct(
        private HttpClientInterface $httpClient,
        private CacheInterface $cache
    ) {}
// ... lines 15 - 24
}
```

Итак, он выглядит по-другому, но это точно то же самое, что было у нас раньше.

Когда мы попробуем это... да! Это все еще работает.

Далее: Я продолжаю говорить, что контейнер содержит сервисы. Это правда! Но он также содержит еще одну вещь — простую конфигурацию, называемую «параметрами».
