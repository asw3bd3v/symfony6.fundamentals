# Non-Autowireable Services

Запустите:

```
php bin/console debug:container
```

И... я сделаю это немного меньше, чтобы все отображалось на одной строке. Как мы знаем, эта команда показывает все службы в нашем контейнере... но только небольшое количество из них являются автосвязываемыми. Мы знаем это, потому что служба является автосвязываемой, только если ее ID, который здесь, является именем класса или интерфейса.

Итак, на первый взгляд может показаться, что служба Twig не является автоматически подключаемой. В конце концов, ее идентификатор — twig — определенно не является классом или интерфейсом. Но если вы прокрутите страницу вверх... давайте посмотрим... да! В контейнере есть еще одна служба, идентификатор которой — Twig\Environment, что является псевдонимом службы twig. Это небольшой трюк, который Symfony использует, чтобы сделать службы автоматически подключаемыми. Если мы указываем аргумент с помощью Twig\Environment, мы получаем службу twig.

Однако большинство служб в этом списке не имеют псевдонима вроде этого. Так что они не являются автоматически подключаемыми. И это обычно нормально. Если служба не является автоматически подключаемой, это, вероятно, потому, что она вам никогда не понадобится. Но давайте представим, что мы хотим использовать одну из них.

Проверьте это! Это называется twig.command.debug. Откройте другую вкладку. Ранее мы запускали:

```
php bin/console debug:twig
```

Это показывает нам все функции и фильтры из Twig... что приятно! Что ж, сюрприз! Эта команда исходит из сервиса twig.command.debug! Потому что "всё в Symfony делается сервисом" - даже консольные команды.

В качестве задачи давайте посмотрим, сможем ли мы внедрить эту службу в MixRepository, запустить ее и вывести ее вывод.

## Внедрение зависимости: добавление нового аргумента

Сначала о главном. В MixRepository мы только что обнаружили, что для выполнения нашей работы нам нужен доступ к другой службе. Что нам делать? Ответ: Внедрение зависимости, которое является этим модным словом для добавления еще одного аргумента конструкции и установки его в свойство, что мы можем сделать все это одновременно с помощью private $twigDebugCommand:

```php
class MixRepository
{
    public function __construct(
// ... lines 13 - 15
        private bool $isDebug,
        private $twigDebugCommand,
    ) {}
// ... lines 19 - 28
}
```

Если мы остановимся прямо сейчас и обновимся... неудивительно! Мы получим ошибку. Symfony понятия не имеет, что передать в качестве этого аргумента.

Что, если мы добавим тип для этого класса? Вернемся в наш терминал, и увидим, что эта служба является экземпляром DebugCommand. Здесь давайте добавим подсказку типа: DebugCommand... нам нужен тот, что из Symfony\Bridge\Twig\Command. Нажмите «tab», чтобы автодополнить это:

```php
use Symfony\Bridge\Twig\Command\DebugCommand;
// ... lines 7 - 11
class MixRepository
{
    public function __construct(
// ... lines 15 - 18
        private DebugCommand $twigDebugCommand,
    ) {}
// ... lines 21 - 30
}
```

И затем... обновить. Все еще ошибка! Хорошо, нам следует добавить подсказку типа, потому что мы хорошие программисты. Но... как бы мы ни старались, это не автосвязываемая служба. Так как же нам это исправить?

## Binding the Argument in YAML

Есть два основных способа. Сначала я покажу вам старый способ, который я в основном использую, потому что вы увидите его в документации и сообщениях блога повсюду. В config/services.yaml, как мы делали ранее для аргумента $isDebug, полностью переопределите нашу службу. Скажите App\Service\MixRepository и добавьте ключ привязки. Затем мы собираемся подсказать, что передать аргументу $twigDebugCommand.

Единственная сложность — выяснить, какое значение установить. Например, если я скопирую идентификатор службы — twig.command.debug — и вставлю его сюда... это не сработает! Это буквально передаст эту строку. Если обновить, то да!

> Аргумент 4 должен иметь тип DebugCommand, задана строка.

Нам нужно сказать Symfony передать службу с этим ID. В этих файлах YAML есть специальный синтаксис, чтобы сделать именно это: добавьте к ID службы префикс @:

```yaml
services:
// ... lines 14 - 32
    App\Service\MixRepository:
        bind:
            $twigDebugCommand: '@twig.command.debug'
```

Как только мы это сделаем... тот факт, что это не взорвется, означает, что это работает!

## The Autowire Attribute

Но... давайте удалим это. Потому что я хочу показать вам новый способ сделать это... который использует тот же самый модный атрибут Autowire.

Здесь, наверху, скажем #[Autowire()], но вместо того, чтобы просто передать строку, скажем service: 'twig.command.debug':

```php
class MixRepository
{
    public function __construct(
// ... lines 15 - 18
        #[Autowire(service: 'twig.command.debug')]
        private DebugCommand $twigDebugCommand,
    ) {}
// ... lines 22 - 31
}
```

## Использование нового аргумента

Мне это нравится! Прежде чем мы попробуем это, давайте на самом деле воспользуемся сервисом. Перейдите к findAll(). Выполнение консольной команды вручную в вашем PHP-коде вполне возможно. Это немного странно, но круто! Нам нужно создать объект $output = new BufferedOutput()... затем мы можем выполнить команду, указав $this->twigDebugCommand->run(new ArrayInput()) - это, своего рода, имитация аргументов командной строки - передайте им пустой [] - затем $output. Все, что выведет команда, будет установлено в этом объекте.

```php
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Output\BufferedOutput;
// ... lines 9 - 13
class MixRepository
{
// ... lines 16 - 24
    public function findAll(): array
    {
        $output = new BufferedOutput();
        $this->twigDebugCommand->run(new ArrayInput([]), $output);
        dd($output);
// ... lines 30 - 35
    }
}
```

Время тестирования! Обновляемся... и получаем! Как это весело?

Хорошо, теперь, когда это работает, давайте закомментируем эту глупость. Я оставлю нашу $twigDebugCommand внедренной просто для справки.

Главный вывод таков: большинство аргументов для служб будут автоматически подключаемыми. Ура! Но когда вы сталкиваетесь с аргументом, который не является автоматически подключаемым, вы можете использовать атрибут Autowire, чтобы указать на необходимое вам значение или службу.

Далее: Помните, я говорил вам, что MixRepository был первым сервисом, который мы когда-либо создавали? Ну... я соврал. Оказывается, наши контроллеры были сервисами все это время!