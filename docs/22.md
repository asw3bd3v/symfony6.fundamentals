# Reading Secrets vs Env Vars

Мы только что создали хранилище секретов для нашей среды разработки... которое будет содержать "безопасную" версию по умолчанию любых конфиденциальных переменных среды. Например, мы устанавливаем значение GITHUB_TOKEN на CHANGEME.

Теперь давайте создадим хранилище среды prod. Сделайте это, сказав:

```
php bin/console secrets:set GITHUB_TOKEN --env=prod
```

На этот раз возьмите настоящее секретное значение из .env.local и вставьте его сюда. Как и раньше, поскольку prod vault еще не существовал, Symfony создал его. И в нем те же четыре файла, что и раньше. Хотя есть одно тонкое, но важное отличие.

Добавьте этот новый каталог в git:

```
git add config/secrets/prod
```

Давайте выполним:

```
git status
```

Ого! Только три из четырех файлов были добавлены. Четвертый файл — ключ расшифровки — игнорируется Git. У нас уже есть строка в .gitignore для этого. Мы не хотим передавать ключ расшифровки prod в репозиторий... потому что любой, у кого есть этот ключ, сможет прочитать все наши секреты.

Итак, если другой разработчик сейчас закроет проект, у него будет ключ расшифровки dev, так что у него не будет проблем с чтением значений из хранилища dev. У него не будет ключа расшифровки prod... но ничего страшного! Единственное место, где вам понадобится ключ расшифровки prod, — это production!

Итак, при такой настройке, при развертывании, вместо необходимости создания целого файла .env.local, содержащего все ваши секреты, вам нужно просто беспокоиться о том, чтобы добавить этот файл prod.decrypt.private.php в ваш код. Или, в качестве альтернативы, вы можете прочитать этот ключ и установить его в переменной среды: вы можете проверить документацию для получения подробной информации о том, как это сделать.

## Using The Secrets Vault

Но... подождите секунду. Я на самом деле не объяснил, как используется хранилище! Мы знаем, что  dev environment будет использовать dev vault... а prod будет использовать prod... но как нам прочитать секреты из хранилища?

Ответ... мы уже есть! Секреты становятся переменными среды. Вот так просто! Так что в config/packages/framework.yaml, используя этот синтаксис env, этот GITHUB_TOKEN может быть реальной переменной среды, или это может быть секрет в нашем хранилище.

Чтобы проверить, работает ли это, перейдите в MixRepository и выполните dd($this->githubContentClient):

```php
class MixRepository
{
// ... lines 16 - 24
    public function findAll(): array
    {
// ... lines 27 - 31
        dd($this->githubContentClient);
// ... lines 33 - 39
    }
}
```

Перейдите, обновите и... давайте посмотрим, сможем ли мы найти заголовок Authorization в этом. На самом деле, есть действительно классный трюк с дампом. Щелкните по этой области и удерживайте "command" или "control" + "F", чтобы выполнить поиск внутри нее. Найдите слово "token" и... о, это не так! Это наш настоящий токен. Но... поскольку мы находимся в среде разработки, разве он не должен читать наше хранилище разработки, где мы установили поддельное значение CHANGEME? Что происходит?

## Секреты должны быть полностью преобразованы из Env Vars

Как я уже говорил, секреты становятся переменными окружения. Но переменные окружения имеют приоритет над секретами: даже переменные окружения, определенные в файлах .env. Да, потому что у нас есть переменная окружения GITHUB_TOKEN, установленная в .env и .env.local, которая имеет приоритет над значением в хранилище!

Вот в чем суть. Как только вы решили преобразовать значение из переменной среды в секрет, вам нужно полностью прекратить устанавливать его как переменную среды. Другими словами, удалите GITHUB_TOKEN в .env, а также в .env.local.

Обновите, нажмите на это еще раз, используйте "command" + "F", найдите "token" и... понял! Мы видим "CHANGEME"! Если бы мы были в среде prod, он бы считывал значение из хранилища prod... предполагая, что ключ расшифровки prod был доступен.

## Команда secrets:list

Хорошо, удалите этот dd() и обновитесь, чтобы обнаружить, что... локально все сломано! Черт! Но... конечно! Теперь он использует этот поддельный токен из хранилища разработки. Он будет нормально работать в продакшене... но как мне исправить мою локальную настройку, чтобы я мог продолжать работать?

Мы могли бы временно переопределить секретное значение GITHUB_TOKEN в хранилище dev, выполнив команду secrets:set. Но... это отстой! Нам нужно быть особенно осторожными, чтобы не зафиксировать измененный, зашифрованный файл.

Прежде чем мы это исправим, я хочу показать вам действительно полезную команду для хранилища:

```
php bin/console secrets:list
```

Да, это показывает вам все секреты в нашем хранилище. Довольно круто! И вы даже можете передать --reveal, чтобы раскрыть значение... пока у вас есть ключ дешифрования.

Вы, возможно, заметили, что он дает нам значение прямо здесь... но затем пишет «Местное значение» с пробелом. Хм...

Повторите команду, но на этот раз добавьте --env=prod.

```
php bin/console secrets:list --reveal --env=prod
```

И... то же самое! Это показывает нам реальную стоимость продукта... но есть еще эта точка "Местная стоимость", где ничего нет.

Это «локальное значение» — ключ к исправлению нашей сломанной настройки разработки: это способ переопределить секрет, но только локально, на нашей одной машине.

Как задать это локальное переопределяющее значение? Скопируйте реальное значение GITHUB_TOKEN, затем перейдите, найдите .env.local — тот же файл, с которым мы работали — и введите GITHUB_TOKEN= и вставьте значение, которое мы только что скопировали.

Да! Локально мы воспользуемся тем фактом, что переменные окружения "побеждают" секреты! Возвращаясь к терминалу, запустите

```
php bin/console secrets:list --reveal
```

снова. Да! Официальное значение в хранилище — «CHANGEME»... но локальное значение — это наш настоящий токен, который, как мы знаем, переопределит секрет и будет использован. Если мы попробуем страницу снова... она сработает!

Ладно, команда! Мы... ну... в общем-то закончили! Так что в качестве награды за вашу тяжелую работу над этими супер важными темами давайте отпразднуем это, используя библиотеку генератора кода Symfony: MakerBundle.