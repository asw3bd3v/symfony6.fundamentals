# Environments

Наше приложение похоже на машину: это набор служб и классов PHP, которые работают... и в конечном итоге отображают некоторые страницы. Но мы можем заставить нашу машину работать по-другому, загрузив в нее другую конфигурацию.

Например, в SongController мы используем службу $logger для регистрации некоторой информации:

```php
class SongController extends AbstractController
{
    #[Route('/api/songs/{id<\d+>}', methods: ['GET'], name: 'api_songs_get_one')]
    public function getSong(int $id, LoggerInterface $logger): Response
    {
// ... lines 16 - 27
    }
}
```

Если мы скормим логеру некоторую конфигурацию, которая говорит "регистрировать все", он будет регистрировать все, включая низкоуровневые отладочные сообщения. Но если мы изменим конфигурацию так, чтобы сказать "регистрировать только ошибки", то это будет регистрировать только ошибки. Другими словами, одна и та же машина может вести себя по-разному в зависимости от нашей конфигурации. И иногда, как с регистрацией, нам может понадобиться, чтобы эта конфигурация была разной, когда мы разрабатываем локально, а не в production.

Чтобы справиться с этим, в Symfony есть важная концепция под названием «окружения». Я не имею в виду окружения типа local vs staging vs beta vs production. Окружение Symfony — это набор конфигураций.

Например, вы можете запустить свой код в среде dev с набором конфигураций, предназначенных для разработки. Или вы можете запустить свое приложение в среде prod с набором конфигураций, оптимизированных для производства. Позвольте мне показать вам!

## Переменная APP_ENV

В корне нашего проекта есть файл .env:

```
# In all environments, the following files are loaded if they exist,
# the latter taking precedence over the former:
#
#  * .env                contains default values for the environment variables needed by the app
#  * .env.local          uncommitted file with local overrides
#  * .env.$APP_ENV       committed environment-specific defaults
#  * .env.$APP_ENV.local uncommitted environment-specific overrides
#
# Real environment variables win over .env files.
#
# DO NOT DEFINE PRODUCTION SECRETS IN THIS FILE NOR IN ANY OTHER COMMITTED FILES.
#
# Run "composer dump-env prod" to compile .env files for production use (requires symfony/flex >=1.2).
# https://symfony.com/doc/current/best_practices.html#use-environment-variables-for-infrastructure-configuration
###> symfony/framework-bundle ###
APP_ENV=dev
APP_SECRET=4777a99cd6c61ce84969bd1338737c38
###< symfony/framework-bundle ###
```

Мы поговорим об этом файле позже. Но видите это APP_ENV=dev? Это говорит Symfony, что текущая среда — dev, что идеально подходит для локальной разработки. Когда мы развернем в production, мы изменим это на prod. Подробнее об этом через несколько минут.

Но... какая разница? Что происходит в нашем приложении, когда мы меняем его с dev на prod? Чтобы ответить, позвольте мне закрыть некоторые папки... и открыть public/index.php:

```php
    use App\Kernel;
    require_once dirname(__DIR__).'/vendor/autoload_runtime.php';
    return function (array $context) {
        return new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);
    };
```

Помните: это наш фронт-контроллер. Это первый файл, который выполняется при каждом запросе. Нас этот файл не особо волнует, но его работа важна: он загружает Symfony.

Интересно, что он считывает значение APP_ENV и передает его в качестве первого аргумента этому классу Kernel. И... этот класс Kernel на самом деле находится в нашем коде! Он находится в src/Kernel.php.

Круто. Так вот что я хочу узнать: что контролирует первый аргумент Kernel?

Если мы откроем класс, то найдем... абсолютно ничего. Он пустой. Это потому, что большая часть логики находится в этом трейте. Удерживайте "cmd" или "control" и щелкните MicroKernelTrait, чтобы открыть его.

## Каталог config/packages/{ENV}

Задача ядра — загрузить все службы и маршруты в нашем приложении. Если вы прокрутите вниз, то увидите метод configureContainer(). Ого! Теперь мы знаем, что такое контейнер! И посмотрите, что он делает! Он берет этот объект $container и импортирует $configDir.'/{packages}/\*.{php,yaml}'. В этой строке говорится:

> Йоу, контейнер! Я хочу загрузить все файлы из каталога config/packages/.

Он загружает все эти файлы, а затем передает конфигурацию из каждого в любой пакет, определенный как корневой ключ. Но что действительно интересно для окружений, так это следующая строка: import $configDir.'/{packages}/'.$this->environment.'/\*.{php,yaml}'. Если вы немного покопаетесь, то узнаете, что $this->environment равен первому аргументу, который передается ядру (Kernel)!

Другими словами, в среде разработки это будет dev. Таким образом, в дополнение к основным файлам конфигурации, это также загрузит все, что находится в каталоге config/packages/dev/. Да, мы можем добавить туда дополнительную конфигурацию, которая переопределяет основную конфигурацию в среде разработки. Например, мы могли бы добавить конфигурацию ведения журнала, которая сообщает регистратору, что нужно вести журнал всего!

Ниже мы также загружаем файл services.yaml и, если он у нас есть, services_dev.yaml. Скоро мы поговорим подробнее о services.yaml.

## The when@{ENV} Config

Итак, если вы хотите добавить конфигурацию, специфичную для среды, вы можете поместить ее в правильный каталог среды. Но есть еще один способ. Это довольно новая функция, и мы видели ее в нижней части twig.yaml. Это синтаксис when@:

config/packages/twig.yaml

```yaml
when@test:
    twig:
        strict_variables: true
```

В Symfony по умолчанию есть три среды: dev, prod, а затем, если вы запускаете автоматизированные тесты, есть среда, называемая test. Внутри twig.yaml, если сказать when@test, это означает, что эта конфигурация будет загружена только в том случае, если среда равна test.

Лучшим примером этого может быть monolog.yaml. monolog — это пакет, который управляет службой логгера. У него есть некоторая конфигурация, которая используется во всех средах. Но ниже этого у него есть when@dev. Мы не будем слишком много говорить о конкретной конфигурации monolog, но она управляет тем, как обрабатываются сообщения журнала. В среде dev это говорит, что он должен регистрировать все и должен регистрировать в файл, используя этот причудливый синтаксис %kernel.logs_dir%, о котором мы скоро узнаем.

В любом случае, это указывает на файл var/logs/dev.log, а часть level: debug означает, что каждое сообщение будет регистрироваться в dev.log... независимо от того, насколько важным или неважным является это сообщение.

Ниже этого, для среды prod, все совсем по-другому. Самая важная строка — action_level: error. Она говорит:

> Привет, мисс Логгер! Это приложение, вероятно, регистрирует массу сообщений, но я хочу, чтобы вы сохраняли только те сообщения, которые имеют уровень важности ошибки или выше.

Это имеет смысл! В производстве мы не хотим, чтобы наши файлы журналов заполнялись тоннами и тоннами отладочных сообщений. При этом мы регистрируем только сообщения об ошибках.

Главное вот в чем: используя эти приемы, мы можем по-разному настраивать наши сервисы в зависимости от среды.

## Маршрутизация, зависящая от среды

И мы даже можем сделать то же самое с маршрутами! Иногда у вас есть целые маршруты, которые вы хотите загрузить только в определенной среде. Возвращаясь к MicroKernelTrait, если вы спуститесь вниз, есть метод configureRoutes(). Это то, что отвечает за загрузку всех наших маршрутов... и это очень похоже на другой код. Он загружает $configDir.'/{routes}/*.{php,yaml}', а также этот каталог среды разработки, если он у вас есть. У нас его нет.

Вы также можете использовать трюк when@dev. Этот файл отвечает за регистрацию маршрутов, используемых панелью инструментов веб-отладки. Мы не хотим, чтобы панель инструментов веб-отладки была в производстве... поэтому эти маршруты импортируются только в среду разработки.

config/routes/web_profiler.yaml

```yaml
when@dev:
    web_profiler_wdt:
        resource: '@WebProfilerBundle/Resources/config/routing/wdt.xml'
        prefix: /_wdt
    web_profiler_profiler:
        resource: '@WebProfilerBundle/Resources/config/routing/profiler.xml'
        prefix: /_profiler
```

Черт, некоторые пакеты включены только в некоторых средах! Если вы откроете config/bundles.php, у нас будет имя пакета... а затем справа среды, в которых этот пакет должен быть включен. Это все означает все среды... и большинство включены во всех средах.

Однако WebProfilerBundle — пакет, который дает нам панель инструментов веб-отладки и профилировщик — загружается только в средах разработки и тестирования. Да, весь пакет — и предоставляемые им сервисы — никогда не загружаются в среде prod.

Итак, теперь, когда мы понимаем основы сред, давайте посмотрим, сможем ли мы переключить наше приложение в среду prod. А затем, в качестве вызова, мы настроим нашу службу кэширования по-другому в dev. Это следующее.
