# Command: Autowiring & Interactive Questions

Хорошо, а что если нам нужна служба из нашей команды? Например, предположим, что мы хотим использовать MixRepository для распечатки рекомендации по миксу винила. Как мы можем это сделать?

Ну, мы внутри сервиса и нам нужен доступ к другому сервису, а это значит, что нам нужна... ужасная инъекция зависимости. Шучу - не ужасная, легко с автосвязыванием!

Добавьте публичную функцию \_\_construct() с приватным MixRepository $mixRepository, чтобы создать и задать все это свойство одновременно.

```php
use App\Service\MixRepository;
// ... lines 6 - 17
class TalkToMeCommand extends Command
{
    public function __construct(
        private MixRepository $mixRepository
    )
    {
        parent::__construct();
    }
// ... lines 26 - 55
}
```

## Интерактивные вопросы

Давайте выведем здесь рекомендацию по миксу... но сделаем это еще круче, сначала спросив пользователя, хочет ли он получить эту рекомендацию.

Мы можем задавать интерактивные вопросы, используя объект $io. Я скажу if ($io->confirm('Вы хотите получить рекомендацию по миксу?')):

```php
class TalkToMeCommand extends Command
{
// ... lines 20 - 34
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
// ... lines 37 - 45
        $io->success($message);
        if ($io->confirm('Do you want a mix recommendation?')) {
// ... lines 49 - 51
        }
// ... lines 53 - 54
    }
}
```

Это задаст этот вопрос, и если пользователь ответит "да", вернет true. Объект $io полон крутых вещей вроде этого, включая вопросы с несколькими вариантами ответов и автозаполнение ответов. Черт, мы даже можем построить индикатор выполнения!

Внутри if получите все миксы с помощью $mixes = $this->mixRepository->findAll(). Затем... нам понадобится всего лишь немного уродливого кода - $mix = $mixes[array_rand($mixes)] - чтобы получить случайный микс.

Вывести микс с помощью еще одного метода $io, передав $io->note(). Я рекомендую микс, а затем вставить $mix['title']:

```php
class TalkToMeCommand extends Command
{
// ... lines 20 - 34
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
// ... lines 37 - 45
        $io->success($message);
        if ($io->confirm('Do you want a mix recommendation?')) {
            $mixes = $this->mixRepository->findAll();
            $mix = $mixes[array_rand($mixes)];
            $io->note('I recommend the mix: ' . $mix['title']);
        }
// ... lines 53 - 54
    }
}
```

И... готово! Кстати, обратите внимание на этот return Command::SUCCESS? Он управляет кодом выхода вашей команды, поэтому вам всегда нужно иметь Command::SUCCESS в конце вашей команды. Если бы произошла ошибка, вы могли бы вернуть Command::FAILURE.

Хорошо, давайте попробуем это! Зайдите в свой терминал и запустите:

```
php bin/console app:talk-to-me --yell
```

Получаем вывод... и затем получаем:

> Do you want a mix recommendation?

Да, конечно! И какая замечательная рекомендация!

Отлично, команда! Мы сделали это! Мы закончили — как мне кажется — самый важный урок по Symfony всех времен! Неважно, что вам нужно построить в Symfony, концепции, которые мы только что изучили, станут основой для этого.

Например, если вам нужно добавить пользовательскую функцию или фильтр в Twig, нет проблем! Вы делаете это, создавая класс расширения Twig... и вы можете использовать MakerBundle, чтобы сгенерировать его для вас или создать его вручную. Это очень похоже на создание пользовательской консольной команды: в обоих случаях вы создаете что-то, чтобы "подключиться" к части Symfony.

Итак, чтобы создать расширение Twig, вам нужно создать новый PHP-класс, реализовать в нем любой интерфейс или базовый класс, который требуется расширениям Twig (в документации об этом сказано)... а затем просто заполнить логику... которую я не буду здесь показывать.

Вот и все! За кулисами ваше расширение Twig будет автоматически отображаться как служба, а автоконфигурация обеспечит его интеграцию в Twig... точно так же, как консольная команда.

В следующем курсе мы задействуем наши новые суперспособности, добавив базу данных в наше приложение, чтобы мы могли загружать реальные, динамические данные. И если у вас есть какие-либо реальные, динамические вопросы, мы здесь для вас, как всегда, в разделе комментариев.

Ладно, друзья. Большое спасибо за кодирование со мной, увидимся в следующий раз.