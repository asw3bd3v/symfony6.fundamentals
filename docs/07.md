# Configuring the Cache Service

Итак... Я хочу знать, как настроить службу кэширования... например, хранить кэш где-то еще. В реальном мире мы можем просто поискать "Как настроить службу кэширования Symfony". Но... мы также можем разобраться с этим самостоятельно, используя команды, которые мы только что изучили.

Мы уже заметили, что есть файл cache.yaml:

```yaml
framework:
    cache:
        # Unique name of your app: used to compute stable namespaces for cache keys.
        #prefix_seed: your_vendor_name/app_name
        # The "app" cache stores to the filesystem by default.
        # The data in this cache should persist between deploys.
        # Other options include:
        # Redis
        #app: cache.adapter.redis
        #default_redis_provider: redis://localhost
        # APCu (not recommended with heavy random-write workloads as memory fragmentation can cause perf issues)
        #app: cache.adapter.apcu
        # Namespaced pools use the above "app" backend by default
        #pools:
            #my.dedicated.cache: null
```

Похоже, FrameworkBundle отвечает за создание службы кэша... и у него есть ключ подкэша, куда мы можем передавать некоторые значения для управления им. Все это на данный момент закомментировано.

Чтобы получить дополнительную информацию о FrameworkBundle, выполните:

```
php bin/console config:dump framework
```

FrameworkBundle — это основной пакет внутри Symfony. Так что вы можете видеть, что это выдает... ух ты... тонну. FrameworkBundle предоставляет множество сервисов... поэтому там много конфигураций.

## Отладка конфигурации кэша

Чтобы немного увеличить масштаб, снова выполните команду, передав framework, а затем cache для фильтрации этого подключа:

```
php bin/console config:dump framework cache
```

И... круто! Это может быть не всегда супер понятно, но это отличная отправная точка. Это определенно помогло нам ответить на вопрос:

> Почему система кэширования хранит данные в каталоге var/cache?

Потому что... есть ключ каталога, который по умолчанию равен %kernel.cache_dir%..., что является замысловатым способом указать на каталог /var/cache/dev. А затем мы видим /pools/app, который является фактическим каталогом, содержащим наш кэш.

## Использование dump() и Profiler

Итак, вот цель: вместо того, чтобы кэшировать вещи в файловой системе, я хочу изменить систему кэширования, чтобы хранить их в другом месте. Перед тем, как мы это сделаем, зайдем в VinylController и, чтобы увидеть результат изменения, которое мы собираемся сделать, dump($cache). До сих пор мы использовали dd(), что означает "dump and die". Но в этом случае я хочу dump()... но дать странице загрузиться.

```php
// src/Controller/VinylController.php
class VinylController extends AbstractController
{
// ... lines 15 - 33
    public function browse(HttpClientInterface $httpClient, CacheInterface $cache, string $slug = null): Response
    {
        $genre = $slug ? u(str_replace('-', ' ', $slug))->title(true) : null;
        dump($cache);
// ... lines 39 - 49
    }
}
```

Обновите сейчас. Подождите, где мой дамп? Это... функция! Когда вы используете dump(), вы на самом деле не увидите его на странице: он прячется здесь, на панели инструментов веб-отладки. Если вы посмотрите туда, кэш — это что-то вроде TraceableAdapter. Но внутри него есть объект FilesystemAdapter. Это доказательство того, что система кэширования сохраняет в файловую систему.

## Настройка адаптера кэша / Configuring the Cache Adapter

Чтобы сделать это хранилище в другом месте, перейдите в cache.yaml и измените этот ключ приложения. Вы можете установить его на ряд различных специальных строк, называемых адаптерами. Если бы мы хотели хранить наш кэш в Redis, мы бы использовали cache.adapter.redis.

Чтобы сделать все по-настоящему просто, используйте cache.adapter.array:

config/packages/cache.yaml

```yaml
framework:
    cache:
// ... lines 3 - 10
        app: cache.adapter.array
// ... lines 12 - 20
```

Адаптер массива — это фейковый кэш, в котором он что-то хранит... но он существует только в течение запроса. Поэтому в конце каждого запроса он все забывает. Это фейковый кэш, но его достаточно, чтобы увидеть, как изменение этого ключа повлияет на саму службу кэша.

Посмотрите, что происходит. В настоящее время у нас есть FilesystemAdapter. Когда мы обновляемся... кэш становится ArrayAdapter! И ​​поскольку ArrayAdapter забывает свой кэш в конце запроса, вы можете видеть, что каждый отдельный запрос теперь делает HTTP-запрос.

## Вывод: все дело в контроле над тем, как создаются экземпляры служб

Если вы немного запутались, позвольте мне попытаться прояснить ситуацию. Цель этой главы не в том, чтобы научить вас, как изменить этот конкретный ключ в файле кэша. В конечном счете, если вам нужно что-то настроить в Symfony, вы просто поищете в документации... которая точно скажет вам, что делать и какой ключ менять.

Нет, главный вывод в том, что единственное назначение этих файлов конфигурации — настройка служб в нашем приложении. Каждый раз, когда вы меняете ключ в любом из этих файлов, конечным результатом является то, что вы просто меняете способ создания экземпляра какой-то службы. Изменение ключа может изменить все имя класса объекта службы, как в этом случае, или может изменить 2-й или 3-й аргумент конструктора, который будет передан при создании экземпляра службы. На самом деле неважно, что именно изменится, пока вы понимаете, что эта конфигурация посвящена службам и способу их создания.

На самом деле, ни один из этих конфигураций не может быть прочитан напрямую из вашего приложения. Например, вы не могли бы запросить конфигурацию "кэша" изнутри контроллера. Нет, Symfony считывает эту конфигурацию, использует ее для настройки того, как будет создаваться экземпляр каждого объекта службы, а затем выбрасывает ее. Службы — это верховенство.

Далее, иногда вам понадобится, чтобы определенная конфигурация отличалась в зависимости от того, разрабатываете ли вы локально или работаете в продакшне. В Symfony есть система для этого, называемая "окружения". Давайте узнаем об этом все.