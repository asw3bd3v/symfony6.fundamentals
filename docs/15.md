# All About services.yaml

Когда Symfony впервые загружается, ему нужно получить полный список всех сервисов, которые должны быть в контейнере. Это включает идентификатор сервиса, имя его класса и все аргументы его конструктора. Первым и самым большим источником сервисов являются пакеты. Если вы запустите

```
php bin/console debug:container
```

подавляющее большинство этих сервисов поступают из пакетов. Второе место, откуда контейнер получает сервисы, — это наш код. И чтобы узнать о наших сервисах, Symfony читает services.yaml.

## The Special _defaults Section

В тот момент, когда Symfony начинает парсить первую строку этого файла, ничего в нашем каталоге src/ не зарегистрировано как служба в контейнере. Это действительно важно. Добавление наших классов в контейнер — это, по сути, работа этого файла! И то, как он это делает, довольно удивительно. Давайте пройдемся!

Обратите внимание, что конфигурация находится под ключом serivice. Как и parameters, это специальный ключ. И, как следует из названия, все, что находится под ним, предназначено для настройки служб.

Первый подключ в этом файле — _defaults. _defaults — это магический ключ, который позволяет нам определить некоторые параметры по умолчанию, которые будут добавлены ко всем сервисам, зарегистрированным в этом файле. Таким образом, каждый сервис, который мы регистрируем ниже, будет автоматически иметь autowire: true и autoconfigure: true:

config/services.yaml

```yaml
services:
    # default configuration for services in *this* file
    _defaults:
        autowire: true      # Automatically injects dependencies in your services.
        autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.
```

Давайте рассмотрим пример. Самое простое, что вы можете сделать в ключе services, это... зарегистрировать службу! Это то, что мы делаем внизу. Это сообщает контейнеру, что в контейнере должна быть служба App\Service\MixRepository, и мы указали один параметр: bind.

```yaml
services:
    # default configuration for services in *this* file
    _defaults:
        autowire: true      # Automatically injects dependencies in your services.
        autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.
// ... lines 14 - 24
    App\Service\MixRepository:
        bind:
            '$isDebug': '%kernel.debug%'
```

Службы на самом деле могут иметь кучу опций, включая autowire и autoconfigure. Так что было бы совершенно законно сказать autowire: true и autoconfigure: true прямо здесь. Это бы работало просто отлично. Но благодаря разделу _defaults они не нужны! _defaults говорит:

> Если это не было переопределено для конкретной службы, установите для autowire и autoconfigure значение true для всех служб в этом файле.

А что делает autowire? Все просто! Он сообщает контейнеру Symfony:

> Эй! Попробуйте угадать аргументы моего конструктора, посмотрев на их подсказки по типу.

Эта функция довольно крутая... поэтому она автоматически включена для всех наших сервисов. Другая опция - автоконфигурация - более тонкая, и мы поговорим о ней позже.

## Service Auto-Registration

Хорошо, к тому времени, как мы дойдем до строки _defaults, мы уже установили некоторую конфигурацию по умолчанию... но мы еще не зарегистрировали ни одной службы. Это работа следующего раздела... и это ключ ко всему:

```yaml
services:
// ... lines 9 - 13
    # makes classes in src/ available to be used as services
    # this creates a service per class whose id is the fully-qualified class name
    App\:
        resource: '../src/'
        exclude:
            - '../src/DependencyInjection/'
            - '../src/Entity/'
            - '../src/Kernel.php'
```

Этот специальный синтаксис говорит:

> Пожалуйста, загляните в каталог src/ и автоматически зарегистрируйте все PHP-классы как службы... за исключением этих трех вещей.

Вот почему, сразу после того, как мы создали класс MixRepository, он уже был в контейнере! А благодаря разделу _defaults, любые сервисы, зарегистрированные этим, будут автоматически иметь autowire: true и autoconfigure: true. Это серьезная командная работа! Этот механизм называется «Авторегистрация сервисов».

Но помните, что каждая служба в контейнере должна иметь уникальный идентификатор. Если вы посмотрите на debug:container, большинство идентификаторов служб имеют регистр Snake. Позвольте мне немного уменьшить масштаб, чтобы было легче увидеть. Лучше! Так, например, служба Twig имеет идентификатор twig в регистре Snake. Но если вы прокрутите этот список до самого верха, наш идентификатор MixRepository — это... полное имя класса.

Да! Когда вы используете Service Auto-Registration, он использует имя класса и как класс, и как идентификатор сервиса. Это делается для простоты... но также и для автосвязывания. Когда мы пытаемся автоматически связать MixRepository с нашим контроллером или куда-либо еще, чтобы выяснить, какой сервис нам передать, Symfony будет искать сервис, идентификатор которого точно совпадает с App\Service\MixRepository. Таким образом, Service Auto-Registration не только регистрирует наши классы как сервисы, он делает это таким образом, что делает их автосвязываемыми. Это потрясающе!

## Auto-Registration of Non-Services?

В любом случае, после этого раздела здесь каждый класс в src/ теперь зарегистрирован как служба в контейнере. За исключением, ну... мы не хотим, чтобы каждый класс в src/ был службой.

На самом деле в вашем приложении есть два типа классов: «классы служб», которые работают, и «классы моделей» — иногда называемые «DTO» — чья работа в основном заключается в хранении данных — например, класса Product со свойствами name и price. Мы хотим, чтобы контейнер обрабатывал создание экземпляров наших служб. Но для классов моделей мы будем создавать их всякий раз, когда они нам понадобятся — например, с помощью $product = new Product(). Таким образом, это не будут службы в контейнере.

В следующем уроке мы создадим классы сущностей Doctrine, которые являются классами моделей для базы данных. Они будут находиться в каталоге src/Entity/... и поскольку они не предназначены для использования в качестве служб, этот каталог исключен. Поэтому мы регистрируем все в каталоге src/ как службу, за исключением этих трех вещей.

Но... забавный факт! Этот ключ исключения не так уж и важен. Черт, вы можете удалить его, и все будет работать! Если вы случайно зарегистрируете что-то как службу, которая не должна быть службой, не беспокойтесь! Поскольку вы никогда не попытаетесь выполнить автосвязывание и использовать этот класс как службу, Symfony поймет, что он не используется, и удалит его из контейнера. Черт, это умно!

## Custom Service Configuration

Таким образом, все в src/ автоматически регистрируется как служба, без необходимости с нашей стороны что-либо делать или трогать этот файл.

Но... иногда вам нужно будет добавить дополнительную конфигурацию к определенной службе. Это то, что произошло с MixRepository благодаря его неавтоподключаемому аргументу $isDebug.

Чтобы исправить это, в нижней части этого файла мы регистрируем новую службу, идентификатор и класс которой — App\Service\MixRepository. Это фактически переопределит службу, созданную во время автоматической регистрации службы, поскольку оба идентификатора будут соответствовать App\Service\MixRepository. Таким образом, мы определяем совершенно новую службу.

Но благодаря _defaults, он автоматически имеет autowire: true и autoconfigure: true. Затем мы добавляем дополнительную опцию bind.

Итак, единственное, что нам нужно поместить в конец этого файла, это службы, которым нужна дополнительная настройка для работы. И... на самом деле есть более крутой способ исправить неавтоподключаемые аргументы, который я вам покажу далее.

## Все файлы конфигурации равноправны!

Но прежде чем мы дойдем до этого, я хочу упомянуть еще одну вещь: этот файл, services.yaml, загружается через ту же систему, которая загружает все файлы в config/packages/. На самом деле, нет никакой технической разницы между этим файлом и, скажем... framework.yaml. Все верно! Если бы мы захотели, мы могли бы скопировать и удалить содержимое services.yaml, вставить его в framework.yaml, и все бы работало точно так же.

За исключением того, что... нам нужно будет, знаете ли, просто исправить эти пути, так как мы на один каталог глубже. Смотрите! Я перемещу это очень быстро и... это все еще работает просто отлично! Круто! Давайте вернем это, как было, и... вот так.

Единственная причина, по которой у нас есть файл service.yaml, — это организация. Приятно иметь один файл для «настройки ваших служб». По-настоящему важно то, что вся эта конфигурация находится в ключе services. Фактически, в верхней части этого файла вы заметите пустой ключ параметров.

В cache.yaml мы создали ключ параметров, чтобы зарегистрировать новый параметр. На самом деле, нам решать, где мы хотим определить этот параметр. Мы можем сделать это в cache.yaml или, чтобы сохранить все параметры в одном месте, мы можем скопировать его и переместить в services.yaml.

В cache.yaml я также возьму when@dev, удалю его и вставлю в services.yaml:

config/services.yaml

```yaml
parameters:
    cache_adapter: 'cache.adapter.filesystem'
when@dev:
    parameters:
        cache_adapter: 'cache.adapter.array'
```

На техническом уровне это не имеет значения, и наше приложение все еще работает. Но мне это нравится больше. Службы и параметры — это глобальная идея в вашем приложении... поэтому неплохо организовать их все в одном файле.

Хорошо, единственная причина, по которой мы написали какой-либо код в нижней части services.yaml, — это сообщить контейнеру, что передать неавтоподключаемому аргументу $isDebug. Но что, если я скажу вам, что есть более автоматический способ решить эти проблемные аргументы?