# The Cache Service

Теперь, когда мы обновляем страницу просмотра, миксы поступают из репозитория на GitHub! Мы делаем HTTP-запрос к API GitHub, который извлекает этот файл прямо здесь, мы вызываем $response->toArray(), чтобы декодировать этот JSON в массив $mixes... и затем мы отображаем это в шаблоне. Да, этот файл на GitHub — наша временная фейковая база данных!

Одна практическая проблема заключается в том, что каждая загрузка страницы теперь делает HTTP-запрос... а HTTP-запросы медленные. Если бы мы развернули это в производстве, наш сайт, конечно, стал бы настолько популярным, что мы довольно быстро достигли бы нашего предела API GitHub. И тогда эта страница взорвалась бы.

Итак... Я думаю: что если мы кэшируем результат? Мы могли бы сделать этот HTTP-запрос, а затем кэшировать данные на 10 минут или даже час. Это как раз может сработать! Как мы кэшируем вещи в Symfony? Вы угадали: с помощью сервиса! Какого сервиса? Я не знаю! Так что давайте выясним.

## Поиск службы кэширования

Запустите:

```
php bin/console debug:autowiring cache
```

для поиска служб, в названии которых есть слово «cache». И... да! На самом деле их несколько! Одна называется CacheItemPoolInterface, а другая — StoreInterface. Некоторые из них не совсем то, что мы ищем, но CacheItemPoolInterface, CacheInterface и TagAwareCacheInterface — это разные службы, которые можно использовать для кэширования. По сути, они все делают одно и то же... но проще всего использовать CacheInterface.

Давайте воспользуемся этим... с помощью нашего хитрого трюка с автосвязыванием! Добавьте еще один аргумент к нашему методу, типизированному с помощью CacheInterface (убедитесь, что вы получили тот, что из Symfony\Contracts\Cache), и назовите его, как насчет $cache:

```php
// src/Controller/VinylController.php
use Symfony\Contracts\Cache\CacheInterface;
// ... lines 9 - 11
class VinylController extends AbstractController
{
// ... lines 14 - 32
    public function browse(HttpClientInterface $httpClient, CacheInterface $cache, string $slug = null): Response
    {
// ... lines 35 - 46
    }
}
```

Чтобы использовать службу $cache, скопируйте эти две строки из предыдущего примера, удалите их и замените на $mixes = $cache->get(), как будто вы собираетесь извлечь какой-то ключ из кэша. Мы можем придумать любой ключ кэша, какой захотим: как насчет mixes_data.

Объект кэша Symfony работает уникальным образом. Мы вызываем $cache->get() и передаем ему этот ключ. Если этот результат уже существует в кэше, он будет немедленно возвращен. Если его еще нет в кэше, он вызовет наш второй аргумент, который является функцией. Здесь наша задача — вернуть данные, которые должны быть кэшированы. Вставьте две строки кода, которые мы скопировали ранее. Этот $httpClient не определен, поэтому нам нужно добавить use ($httpClient), чтобы включить его в область действия.

Вот и все! И вместо установки переменной $mixes просто верните эту строку $response->toArray():

```php
class VinylController extends AbstractController
{
// ... lines 14 - 32
    public function browse(HttpClientInterface $httpClient, CacheInterface $cache, string $slug = null): Response
    {
// ... lines 35 - 36
        $mixes = $cache->get('mixes_data', function() use ($httpClient) {
            $response = $httpClient->request('GET', 'https://raw.githubusercontent.com/SymfonyCasts/vinyl-mixes/main/mixes.json');
            return $response->toArray();
        });
// ... lines 42 - 46
    }
}
```

Если вы раньше не использовали службу кэширования Symfony, это может показаться странным! Но мне это нравится! Когда мы обновляем страницу в первый раз, в кэше еще не будет mixes_data. Поэтому она вызовет нашу функцию, вернет результат, а затем система кэширования сохранит его в кэше. В следующий раз, когда мы обновим страницу, ключ будет в кэше, и она немедленно вернет результат. Поэтому нам не нужны никакие операторы "if", чтобы проверить, есть ли что-то в кэше... только это!

## Отладка с помощью Cache Profiler

Но... смешается ли? Давайте узнаем. Обновляем и... прекрасно! Первое обновление все еще делало HTTP-запрос обычным. Внизу на панели инструментов отладки веб-страницы мы видим, что было три вызова кэша и одна запись кэша. Откройте это в новой вкладке, чтобы перейти в раздел кэша профайлера.

Круто: это показывает нам, что был один вызов кэша для mixes_data, одна запись кэша и один промах кэша. Промах кэша означает, что он вызвал нашу функцию и записал ее в кэш.

При следующем обновлении обратите внимание на этот значок. Он исчезает! Это потому, что не было HTTP-запроса. Если вы снова откроете Cache Profiler, на этот раз было одно чтение и одно попадание. Это попадание означает, что результат был загружен из кэша, и он не сделал HTTP-запрос. Это именно то, что мы хотели!

## Установка времени жизни кэша

Теперь вы можете задаться вопросом: как долго эта информация будет храниться в кэше? Прямо сейчас... вечно. Ооох. Это по умолчанию.

Чтобы сделать его устаревшим раньше, чем навсегда, дайте функции аргумент CacheItemInterface — не забудьте нажать «tab», чтобы добавить этот оператор use — и назовите его $cacheItem. Теперь мы можем сказать $cacheItem->expiresAfter() и, для простоты, сказать 5:

```php
use Psr\Cache\CacheItemInterface;
// ... lines 6 - 12
class VinylController extends AbstractController
{
// ... lines 15 - 33
    public function browse(HttpClientInterface $httpClient, CacheInterface $cache, string $slug = null): Response
    {
// ... lines 36 - 37
        $mixes = $cache->get('mixes_data', function(CacheItemInterface $cacheItem) use ($httpClient) {
            $cacheItem->expiresAfter(5);
            $response = $httpClient->request('GET', 'https://raw.githubusercontent.com/SymfonyCasts/vinyl-mixes/main/mixes.json');
            return $response->toArray();
// ... lines 44 - 42
        });
// ... lines 44 - 48
    }
}
```

Срок действия элемента истекает через 5 секунд.

## Очистка кэша

К сожалению, если мы попробуем это, элемент, который уже находится в кэше, будет установлен на то, что он никогда не истечет. Так что... это не сработает, пока мы не очистим кэш. Но... где хранится кэш? Еще один отличный вопрос! Мы поговорим об этом подробнее через секунду... но по умолчанию он хранится в var/cache/dev/... вместе с кучей других файлов кэша, которые помогают Symfony выполнять свою работу.

Мы могли бы удалить этот каталог вручную, чтобы очистить кэш... но у Symfony есть способ получше! Это, конечно, еще одна команда bin/console.

Symfony имеет множество различных «категорий» кэша, называемых «пулами кэша». Если вы запустите:

```
php bin/console cache:pool:list
```

вы увидите их все. Большинство из них предназначены для внутреннего использования Symfony. Пул кэша, который мы используем, называется cache.app. Чтобы очистить его, выполните:

```
php bin/console cache:pool:clear cache.app
```

Вот и все! Это не то, что вам придется делать очень часто, но знать об этом полезно, на всякий случай.

Хорошо, проверьте это. Когда мы обновляем... мы получаем промах кэша, и вы можете видеть, что он сделал HTTP-вызов. Но если мы обновим снова очень быстро... он исчезнет! Обновляем снова и... он снова есть! Это потому, что пять секунд только что истекли.

Итак, команда: теперь мы используем клиентскую службу HTTP и службу кэширования... обе из которых были подготовлены для нас одним из наших пакетов, так что мы можем просто... использовать их!

Но у меня есть вопрос. А что, если нам нужно контролировать эти сервисы? Например, как мы можем сообщить сервису кэширования, что вместо сохранения вещей в файловой системе в этом каталоге мы хотим хранить вещи в Redis... или memcache? Давайте рассмотрим идею управления нашими сервисами через конфигурацию далее.