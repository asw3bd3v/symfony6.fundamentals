# Environment Variables

Откройте config/packages/framework.yaml. Нам не нужно проходить аутентификацию, чтобы использовать эту часть необработанного пользовательского контента API GitHub:

```yaml
framework:
// ... lines 3 - 19
    http_client:
        scoped_clients:
            githubContentClient:
                base_uri: https://raw.githubusercontent.com
```

Но если мы будем часто заходить на эту конечную точку, мы можем столкнуться с их ограничением скорости, которое довольно низко для анонимных пользователей. Так что давайте аутентифицируем наш запрос.

## Добавление заголовка авторизации в HTTP-запрос

Во-первых, если вы пишете код вместе со мной, перейдите на "github.com" и создайте свой собственный токен доступа. После этого откройте MixRepository и перейдите туда, где мы делаем HTTP-запрос. Чтобы прикрепить токен доступа к запросу, передайте третий аргумент, который является массивом. Внутри добавьте набор ключей заголовков к другому массиву с заголовком Authorization, назначенным слову Token, а затем токену доступа. Начните с использования поддельного токена:

```php
class MixRepository
{
// ... lines 16 - 24
    public function findAll(): array
    {
// ... lines 27 - 32
        return $this->cache->get('mixes_data', function(CacheItemInterface $cacheItem) {
// ... line 34
            $response = $this->githubContentClient->request('GET', '/SymfonyCasts/vinyl-mixes/main/mixes.json', [
                'headers' => [
                    'Authorization' => 'Token ghp_foo_bar',
                ]
            ]);
// ... lines 40 - 41
        });
    }
}
```

Вы можете сказать, что это работает, потому что, когда мы возвращаемся на страницу и обновляем ее... она взрывается! Наш вызов API теперь терпит неудачу с кодом 404, потому что он распознает, что мы пытаемся пройти аутентификацию с помощью токена... но тот, который мы передали, является поддельным.

Теперь добавьте свой настоящий токен. Попробуйте еще раз и... это работает!

## Перемещение заголовка авторизации в framework.yaml

Так что это круто! Но было бы лучше, если бы служба была предварительно настроена для автоматической установки этого заголовка авторизации... особенно, если мы хотим использовать эту службу HTTP-клиента в нескольких местах. Можем ли мы это сделать? Конечно!

Скопируйте строку Token, перейдите в framework.yaml и после base_uri передайте ключ заголовков с Authorization, установленным на нашу длинную строку. На самом деле, позвольте мне временно поместить туда поддельный токен:

config/packages/framework.yaml

```yaml
framework:
// ... lines 3 - 19
    http_client:
        scoped_clients:
            githubContentClient:
                base_uri: https://raw.githubusercontent.com
                headers:
                    Authorization: 'Token ghp_FAKE'
```

Вернитесь в MixRepository и удалите третий аргумент:

```php
class MixRepository
{
// ... lines 16 - 24
    public function findAll(): array
    {
// ... lines 27 - 32
        return $this->cache->get('mixes_data', function(CacheItemInterface $cacheItem) {
// ... line 34
            $response = $this->githubContentClient->request('GET', '/SymfonyCasts/vinyl-mixes/main/mixes.json');
// ... lines 36 - 37
        });
    }
}
```

И теперь, когда мы пробуем это... отлично! Все сломалось, что доказывает, что мы отправляем этот заголовок... просто с неправильным значением. Если мы изменим его на наш настоящий токен... еще раз... это работает! Потрясающе!

## Привет, переменные среды

Пока что это просто приятная функция HttpClient. Но это также помогает выявить распространенную проблему. Это... не очень здорово, что наш чувствительный токен API GitHub жестко закодирован в этом файле. Я имею в виду, что этот файл будет передан в наш репозиторий. Я люблю своих коллег по команде... но я не люблю их настолько, чтобы делиться с ними своим токеном доступа... или токеном доступа для нашей компании.

Вот тут-то и пригодятся переменные окружения. Если вы не знакомы с переменными окружения, это переменные, которые вы можете задать в любой системе (Windows, Linux, что угодно)... и затем вы можете прочитать их изнутри PHP. Многие хостинговые платформы делают установку этих переменных очень простой. Как это нам поможет? Потому что, теоретически, мы могли бы задать наш токен доступа как переменную окружения, а затем просто прочитать его в PHP. Это позволило бы нам избежать помещения этого чувствительного значения в наш код.

## Чтение переменных среды

Но прежде чем мы поговорим о настройке переменных окружения, как мы считываем переменные окружения в Symfony? Скопируйте свой токен доступа, чтобы не потерять его, заключите токен в одинарные кавычки, а затем мы будем использовать очень специальный синтаксис для считывания переменной окружения. На самом деле это будет выглядеть как параметр. Начинайте и заканчивайте с %, а внутри, скажем, env() с именем переменной окружения. Как насчет GITHUB_TOKEN. Я только что придумал это имя:

config/packages/framework.yaml

```yaml
framework:
// ... lines 3 - 19
    http_client:
        scoped_clients:
            githubContentClient:
                base_uri: https://raw.githubusercontent.com
                headers:
                    Authorization: 'Token %env(GITHUB_TOKEN)%'
```

Если вернуться назад и обновить страницу... то теперь мы считываем переменную среды GITHUB_TOKEN... но мы ее еще не установили, поэтому получаем ошибку «Переменная среды не найдена».

## Настройка переменных среды и .env

В реальном мире настройка переменных окружения... на самом деле довольно сложная задача. В Windows и Linux все по-разному. И хотя многие хостинговые платформы действительно позволяют очень легко настраивать переменные окружения, сделать это локально на вашем компьютере не так-то просто.

Вот почему существует этот файл .env. Очень просто: когда Symfony загружается, он считывает файл .env и превращает все это в переменные окружения. Это значит, что мы можем сказать GITHUB_TOKEN= и вставить наш токен... и вот... он работает!

.env

```
###< symfony/framework-bundle ###
GITHUB_TOKEN=
```

Кстати, если бы в моей системе была установлена ​​настоящая переменная среды GITHUB_TOKEN, то эта настоящая переменная среды победила бы то, что есть в этом файле.

## Файл .env.local

Ладно... это круто... но у нас все та же проблема! У нас есть конфиденциальное значение, которое находится внутри файла... который зафиксирован в нашем репозитории.

Хорошо, тогда давайте попробуем что-нибудь еще. Скопируйте токен GitHub, удалите значение из этого файла, а затем создайте новый файл с именем .env.local. Установите переменную окружения здесь.

И теперь... все по-прежнему работает! 

Вот в чем дело. Когда Symfony загружается, он сначала считывает файл .env и превращает все это в переменные среды. Затем он считывает .env.local и превращает все, что там есть, в переменные среды... которые переопределяют любые значения, заданные в .env.

В результате ваш файл .env должен содержать безопасные значения по умолчанию, которые можно зафиксировать в вашем репозитории. Затем локально (а может быть, и в рабочей среде, в зависимости от того, как вы развертываете) вы создаете файл .env.local и помещаете туда конфиденциальные значения. Главное, что .env.local игнорируется Git. Вы можете видеть, что он уже есть в нашем файле .gitignore. Поэтому, хотя этот файл будет содержать конфиденциальные значения, он не будет зафиксирован в репозитории.

Есть еще несколько файлов .env, которые вы можете создать... и вы можете увидеть их упоминание здесь. Они не так важны, но если вы хотите прочитать о них, вы можете ознакомиться с документацией.

## Визуализация переменных окружения с помощью debug:dotenv

Еще одна замечательная особенность переменных окружения заключается в том, что вы можете визуализировать их, выполнив:

```
php bin/console debug:dotenv
```

Отлично! Вы можете видеть текущее значение GITHUB_TOKEN... и то, что это значение также установлено в .env.local. Напротив, APP_ENV и APP_SECRET имеют здесь n/a, что означает, что их значения не переопределяются в .env.local. Он также сообщает нам, какие файлы .env он обнаружил.

## Env Var Processors

Есть несколько трюков, которые можно использовать с переменными окружения. Например, есть нечто, называемое «процессорной системой», где можно использовать trim для «обрезки» пробелов в GITHUB_TOKEN. Или можно использовать file, где переменная GITHUB_TOKEN на самом деле является путем к файлу, содержащему истинное значение. В любом случае, они называются «процессорами env var», если вы хотите узнать о них больше.

Далее, давайте быстро поговорим о развертывании... но еще больше о том, как мы можем безопасно хранить эти конфиденциальные значения при развертывании в производство. Одним из вариантов является хранилище секретов Symfony.